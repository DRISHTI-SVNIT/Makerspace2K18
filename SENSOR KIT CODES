//BLINK,TOGGLE & DEBOUNCE//

/*
 * tog.c
 *
 * Created: 1/27/2019 4:03:44 PM
 * Author : Siddharth Reddy
 */ 

//LED start

#include <avr/io.h>
int main(void)
{
	DDRB = 0b00000001; //Data Direction Register setting pin0 to output and the remaining pins as input
	PORTB = 0b00000001; //Set pin0 to 5 volts
	while(1)
	{
		//Code would be in here if it needed to execute over and over and over ... endlessly
	}
}
//LED Blink

#include <avr/io.h>
#include <util/delay.h>

int main(void)
{
	DDRB |= 1 << PINB0;
	while (1)
	{
		PORTB ^= 1 << PINB0;
		_delay_ms(100);
	}
}

/*Button Debouncing*/

#include <avr/io.h>
#include <util/delay.h>
int main(void)
{
	DDRB |= 1 << PINB0; //Set Direction for output on PINB0
	PORTB |= 1 << PINB0; //Toggling only Pin 0 on port b
	DDRB |= 1 << PINB2; //Set Direction for Output on PINB2
	DDRB &= ~(1 << PINB1); //Data Direction Register input PINB1
	PORTB |= 1 << PINB1; //Set PINB1 to a high reading
	int Pressed = 0; //Initialize/Declare the Pressed variable

	while (1)
	{
		if (bit_is_clear(PINB, 1)) //Check is the button is pressed
		{
			//Make sure that the button was released first
			if (Pressed == 0)
			{
				PORTB ^= 1 << PINB0;
				_delay_ms(1000); //Toggle LED in pin 0
				PORTB ^= 1 << PINB2;
				_delay_ms(1000); //Toggle LED on pin 2
				Pressed = 1;
			}
		}
		else
		{
			//This code executes when the button is not pressed.
			Pressed = 0;
		}
	}
}

//Button Debouncing 2

int main(void)
{
	DDRB |= 1 << PINB0; //For Notes on what these actions mean
	PORTB ^= 1 << PINB0;
	DDRB |= 1 << PINB2;
	DDRB &= ~(1 << PINB1);
	PORTB |= 1 << PINB1;

	int Pressed = 0;
	int Pressed_Confidence_Level = 0; //Measure button press cofidence
	int Released_Confidence_Level = 0; //Measure button release confidence

	while (1)
	{
		if (bit_is_clear(PINB, 1))
		{
			Pressed_Confidence_Level ++; //Increase Pressed Conficence
			Released_Confidence_Level = 0; //Reset released button confidence since there is a button press
			if (Pressed_Confidence_Level >500) //Indicator of good button press
			{
				if (Pressed == 0)
				{
					PORTB ^= 1 << PINB0;
					PORTB ^= 1 << PINB2;
					Pressed = 1;
				}
				//Zero it so a new pressed condition can be evaluated
				Pressed_Confidence_Level = 0;
			}
		}
		else
		{
			Released_Confidence_Level ++; //This works just like the pressed
			Pressed_Confidence_Level = 0; //Reset pressed button confidence since the button is released
			if (Released_Confidence_Level >500
			{
				Pressed = 0;
				Released_Confidence_Level = 0;
			}
		}
	}
}



//Button Game

#include <avr/io.h>
#include <util/delay.h>

void ProcessPressedButton(int ButtonPressed);
void ProcessReleasedButton(int ButtonReleased);
int Pressed_Confidence_Level[2];
int Released_Confidence_Level[2];
int Pressed[2];
int LEDNumber[2];
int main(void)
{
	DDRB = 0b01111111;
	DDRD = 0b01111111;
	PORTB = 0b10000000;
	PORTD = 0b10000000;

	while (1)
	{
		if (bit_is_clear(PINB, 7))
		{
			ProcessPressedButton(0);
		}
		else
		{
			ProcessReleasedButton(0);
		}
		if (bit_is_clear(PIND, 7))
		{
			ProcessPressedButton(1);
		}
		else
		{
			ProcessReleasedButton(1);
		}
	}
}

void ProcessPressedButton(int ButtonPressed)
{
	Pressed_Confidence_Level[ButtonPressed] ++;
	if (Pressed_Confidence_Level[ButtonPressed] > 500)
	{
		if (Pressed[ButtonPressed] == 0)
		{
			Pressed[ButtonPressed] = 1;
			if (ButtonPressed == 0) PORTB |= 1 << LEDNumber[ButtonPressed];
			if (ButtonPressed == 1) PORTD |= 1 << LEDNumber[ButtonPressed];
			LEDNumber[ButtonPressed] ++;
			if (LEDNumber[ButtonPressed] >6)
			{
				for(int i=0;i < 10;i++)
				{
					if (ButtonPressed == 0) PORTB = 0b11111111;
					if (ButtonPressed == 1) PORTD = 0b11111111;
					_delay_ms(10);
					if (ButtonPressed == 0) PORTB = 0b10000000;
					if (ButtonPressed == 1) PORTD = 0b10000000;
					_delay_ms(10);
				}
				LEDNumber[0] = 0;
				LEDNumber[1] = 0;
				PORTB = 0b10000000;
				PORTD = 0b10000000;
			}
		}
		Pressed_Confidence_Level[ButtonPressed] = 0;
	}
}

void ProcessReleasedButton(int ButtonReleased)
{
	Released_Confidence_Level[ButtonReleased] ++;
	if (Released_Confidence_Level[ButtonReleased] > 500)
	{
		Pressed[ButtonReleased] = 0;
		Released_Confidence_Level[ButtonReleased] = 0;
	}
}









//IR SENSOR


/*
 * IR SEN.c
 *
 * Created: 1/27/2019 4:36:04 PM
 * Author : Siddharth Reddy
 */ 

#include <avr/io.h>
#include <util/delay.h>


int main(void)
{
    DDRB |= (1<<PINB0);
	DDRB |= (1<<PINB2);
	DDRB &= ~(1<<PINB1);
	
	
	void glow()
	{
		PORTB &= ~(1<<PINB2);
		PORTB ^= (1<<PINB0);
		
		
		
	}
	void off()
	{
		PORTB &= ~(1<<PINB0);
		PORTB ^= (1<<PINB2);
		
		
	}
	
    while (1) 
    {
		if (bit_is_clear(PINB,1))
		{
			glow();
		_delay_ms(1000);
		}
		else
		{
			off();
			_delay_ms(1000);
		}
    }
}


//ULTRASONIC


#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdio.h>
#define SCALE_FACTOR      3
#define clock_frequency     8000000UL
#define microseconds        clock_frequency/1000000
#define milliseconds        clock_frequency/1000
void init_usart(unsigned int baud);
void usart_putchar(char data);

void send2uart(char *buffer);
void send_ATcommand(char *buffer);
void print_uart(char *buffer);

char process_uart_data(char uart_buffer);



#define    BIT7    0x80
#define    BIT6    0x40
#define    BIT5    0x20
#define    BIT4    0x10
#define    BIT3    0x08
#define    BIT2    0x04
#define    BIT1    0x02
#define    BIT0    0x01


#define BAUD_9600     51


//#define BAUD_57600    8




char rx_buffer[20];  //rx buffer chat length
char buff_index;

void init_usart(unsigned int baud)   
{   
    UCSR0A=(0x00);   
    UCSR0B=0x98;      // reciever disabled, receive interrrupt disabled, tx enabled   
    UCSR0C=0x86;      // 8-bit mode   
    UBRR0H=baud>>8;   
    UBRR0L=baud;  
       
    }
 
void usart_putchar(char data)   
{   
   while(!(UCSR0A & BIT5));
   //Now write the data to USART buffer
   UDR0=data;      
} 

void send2uart(char *buffer)
{
  int i;
  for (i=0;buffer[i] != '\0' ;i++)
  usart_putchar(buffer[i]);
}

void send_ATcommand(char *buffer)
{
  send2uart(buffer);
  usart_putchar(0x0D);
}

void print_uart(char *buffer)
{
  int i;
  for (i=0;buffer[i] != '\0' ;i++)
  usart_putchar(buffer[i]);
  usart_putchar(0x0D);
  usart_putchar(0x0A);
  }


void integer_to_char(int integer_input, char* character_array, char type)
{
	int reminder,quotient;
	if (type == 2)
	{
		quotient = integer_input/10;
		reminder = integer_input%10;
		character_array[0] = quotient+0x30;
		character_array[1] = reminder+0x30;
		character_array[2] = '\0';
	}
	if (type == 3)
	{
		quotient = integer_input/100;
		reminder = integer_input%100;
		character_array[0] = quotient+0x30;
		quotient = reminder/10;
		reminder = reminder%10;
		character_array[1] = quotient+0x30;
		character_array[2] = reminder+0x30;
		character_array[3] = '\0';
	}
	if (type == 4)
	{
		quotient = integer_input/1000;	// 1234  -- 1
		reminder = integer_input%1000;	// 234
		character_array[0] = quotient+0x30;	    //'1'
		quotient = reminder/100;	       // 234  -- 2
		reminder = reminder%100;	       // 34
		character_array[1] = quotient+0x30;	  // '2'
		quotient = reminder/10;	        //  3
		reminder = reminder%10;
		character_array[2] = quotient+0x30;
		character_array[3] = reminder+0x30;
		character_array[4] = '\0';
	}
}


void hex_to_char(char hex,char character_array[3])
{
	if (((hex & 0xF0) >> 4 )>9)
	{
		character_array[0] = (((hex & 0xF0) >> 4 ) + 0x37);
	}
	else
	{
		character_array[0] = (((hex & 0xF0) >> 4 ) + 0x30);
	}
	if((hex & 0x0F)>9)
	{    character_array[1] = ((hex & 0x0F) + 0x37);
	}
	else
	{
		character_array[1] = ((hex & 0x0F) + 0x30);
	}
	character_array[2] = '\0';
}


char char2num(char character)
{
	char result = 0;
	if ((character >= 0x30) && (character <= 0x39))
	result =  (character-0x30);
	else
	result = 0;
	
	return result;
}


long map(long x, long in_min, long in_max, long out_min, long out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

int char_to_int(char character_array[3], char type)
{
	int integer = 0;
	if (type == 1)
	{
		integer += (character_array[0]-0x30);
	}
	else if (type == 2)
	{
		integer += ((character_array[0]-0x30)*10);
		integer += (character_array[1]-0x30);
	}
	else if (type == 3)
	{
		integer += ((character_array[0]-0x30)*100);
		integer += ((character_array[1]-0x30)*10);
		integer += (character_array[2]-0x30);
	}
	else if (type == 4)
	{
		integer += ((character_array[0]-0x30)*1000);
		integer += ((character_array[1]-0x30)*100);
		integer += ((character_array[2]-0x30)*10);
		integer += (character_array[3]-0x30);
	}
	return integer;
}
#define CON_CAT(a,b)                a ## b
#define DDR_(name)        CON_CAT(DDR,name)
#define PORT_(name)       CON_CAT(PORT,name)
#define PIN_(name)        CON_CAT(PIN,name)
#define BIT_(name)        CON_CAT(BIT,name)

/*Need to change according to connections*/
#define ULTRASONIC_PORT_IND        B              /*need to configure here */
#define ULTRASONIC_TRIGGER         0               /*need to configure trigger pin(0-7) */
#define ULTRASONIC_ECHO            1               /*need to configure echo pin(0-7) */

/*  ULTRASONIC 1  */

#define Ultrasonic_Triger_Port_Direction            DDR_(ULTRASONIC_PORT_IND)
#define Ultrasonic_Triger_Port                      PORT_(ULTRASONIC_PORT_IND)
#define Ultrasonic_Trigger_pin                      BIT_(ULTRASONIC_TRIGGER)


#define Ultrasonic_Echo_Port_Direction              DDR_(ULTRASONIC_PORT_IND)
#define Ultrasonic_Echo_Port                        PORT_(ULTRASONIC_PORT_IND)
#define Ultrasonic_Echo_Input                       PIN_(ULTRASONIC_PORT_IND)
#define Ultrasonic_Echo_pin                         BIT_(ULTRASONIC_ECHO)

void init_Ultrasonic_sensor(void);
void trigger_Ultrasonic_sensor(void);
unsigned int read_Ultrasonic_sensor(void);
unsigned int get_distance_Ultrasonic_sensor(void);
unsigned int echo_duration;

void init_Ultrasonic_sensor(void)
{
	Ultrasonic_Triger_Port_Direction |= (Ultrasonic_Trigger_pin);    // Ultrasonic Trigger pin
	Ultrasonic_Triger_Port &= ~(Ultrasonic_Trigger_pin);   // Ultrasonic pin set to low
	
	Ultrasonic_Echo_Port_Direction &= ~(Ultrasonic_Echo_pin);   // Ultrasonic Echo pin set to input
	Ultrasonic_Echo_Port |= Ultrasonic_Echo_pin;      // Enable pullup
}

void trigger_Ultrasonic_sensor(void)
{
	Ultrasonic_Triger_Port &= ~(Ultrasonic_Trigger_pin);
	_delay_us(2);
	Ultrasonic_Triger_Port |= (Ultrasonic_Trigger_pin);
	_delay_us(10);
	Ultrasonic_Triger_Port &= ~(Ultrasonic_Trigger_pin);
}

unsigned int read_Ultrasonic_sensor(void)
{
	echo_duration = 0;
	while((Ultrasonic_Echo_Input&Ultrasonic_Echo_pin) != Ultrasonic_Echo_pin);
	while(((Ultrasonic_Echo_Input&Ultrasonic_Echo_pin) == Ultrasonic_Echo_pin) && (echo_duration<20000))
	{
		_delay_us(1);
		echo_duration++;
	}
	return echo_duration;
}


unsigned int get_distance_Ultrasonic_sensor(void)
{
	trigger_Ultrasonic_sensor();
	return read_Ultrasonic_sensor()/SCALE_FACTOR;
}

char data_buffer[4],buffer[50];

int distance = 0,c_m=0,m_m=0;

int convert_cm(int value)
{
 c_m = value/10;



  integer_to_char(c_m,data_buffer,3);
  send2uart(data_buffer);
  send2uart("cm");
  usart_putchar(0x0D);
  usart_putchar(0x0A);
  if(c_m<015)
  {
    sprintf(buffer,"OBSTACLE DETECTED\n");
	send2uart(buffer);
   }
}


int main(void)
{

_delay_ms(1000);
print_uart("OK");


DDRD&=~(BIT3);
PORTD |= BIT3;

init_Ultrasonic_sensor();

if((PIND&BIT3) == BIT3)
{
init_usart(BAUD_9600);
}
else
{
//init_usart(BAUD_57600);
}

while(1)
{
	distance = get_distance_Ultrasonic_sensor();
	convert_cm(distance);
	_delay_ms(100);
}

}




//UART


/*
 * GccApplication8.c
 *
 * Created: 09-02-2019 14:26:45
 * Author : Shubham
 */ 
#define F_CPU 8000000UL// Clock Speed
#include <avr/io.h>
#include <stdio.h>
#include <util/delay.h>
#include <string.h>

//#define BAUD 9600
//#define myubrr (F_CPU/(16*BAUD))-1

void UART_Initialize( unsigned int ubrr );
void UART_Transmit( unsigned char data );
unsigned char UART_Receive( void );

int main(void)
{
	
	char mystr[] = "SensorKit";	
	unsigned int strLength = strlen(mystr);
	unsigned int i = 0;
	UART_Initialize (51); //function calling
	while(1)
	{
		//x=UART_Receive();/
		//_delay_ms(10);/
		UART_Transmit(mystr[i++]);
		_delay_ms(100);
		if(i >= strLength)
		i = 0;
	}
	return(0);
}



void UART_Initialize( unsigned int ubrr )
{
	/* Set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
	UBRR0L = (unsigned char)ubrr;
	/* Enable receiver and transmitter */
	UCSR0B |= (1<<RXEN)|(1<<TXEN);
	/* Set frame format: 8data, 2stop bit */
	UCSR0C |= (1<<USBS)|(3<<UCSZ0);
}


void UART_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) );
	/* Put data into buffer, sends the data */
	UDR0 = data;
}


unsigned char UART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) );
	/* Get and return received data from buffer */
	return UDR0;
}



// I2C


/*
 * i2c1.c
 *
 * Created: 2/13/2019 8:40:12 PM
 * Author : Siddharth Reddy
 */ 

#define F_CPU 8000000UL									/* Define CPU clock Frequency e.g. here its 8MHz */
#include <avr/io.h>										/* Include AVR std. library file */
#include <util/delay.h>									/* Include delay header file */
#include <inttypes.h>									/* Include integer type header file */
#include <stdlib.h>										/* Include standard library file */
#include <stdio.h>										/* Include standard library file */
#include <math.h>								/* Include math function */

#define SCL_CLK 100000L							/* Define SCL clock frequency */
#define BITRATE(TWSR)	((F_CPU/SCL_CLK)-16)/(2*pow(4,(TWSR&((1<<TWPS0)|(1<<TWPS1))))) /* Define bit rate */
#define BAUD_PRESCALE (((F_CPU / (BAUDRATE * 16UL))) - 1)	/* Define prescale value */
#define SMPLRT_DIV 0x19
#define CONFIG 0x1A
#define GYRO_CONFIG 0x1B
#define INT_ENABLE 0x38
#define ACCEL_XOUT_H 0x3B
#define ACCEL_XOUT_L 0x3C
#define ACCEL_YOUT_H 0x3D
#define ACCEL_YOUT_L 0x3E
#define ACCEL_ZOUT_H 0x3F
#define ACCEL_ZOUT_L 0x40
#define TEMP_OUT_H 0x41
#define TEMP_OUT_L 0x42
#define GYRO_XOUT_H 0x43
#define GYRO_XOUT_L 0x44
#define GYRO_YOUT_H 0x45
#define GYRO_YOUT_L 0x46
#define GYRO_ZOUT_H 0x47
#define GYRO_ZOUT_L 0x48
#define PWR_MGMT_1 0x6B


void USART_Init(unsigned long);				/* USART initialize function */
char USART_RxChar();						/* Data receiving function */
void USART_TxChar(char);					/* Data transmitting function */
void USART_SendString(char*);				/* Send string of USART data function */
void intarray(int num);

void I2C_Init();								/* I2C initialize function */
uint8_t  I2C_Repeated_Start(char);				/* I2C repeated start function */
void I2C_Stop();								/* I2C stop function */
void I2C_Start_Wait(char);						/* I2C start wait function */
uint8_t  I2C_Write(char);						/* I2C write function */
char I2C_Read_Ack();							/* I2C read ack function */
char I2C_Read_Nack();							/* I2C read nack function */


float Acc_x,Acc_y,Acc_z,Temperature,Gyro_x,Gyro_y,Gyro_z;


void MPU6050_Init()										/* Gyro initialization function */
{
	_delay_ms(150);										/* Power up time >100ms */
	I2C_Start_Wait(0xD0);								/* Start with device write address */
	I2C_Write(SMPLRT_DIV);								/* Write to sample rate register */
	I2C_Write(0x07);									/* 1KHz sample rate */
	I2C_Stop();

	I2C_Start_Wait(0xD0);
	I2C_Write(PWR_MGMT_1);								/* Write to power management register */
	I2C_Write(0x01);									/* X axis gyroscope reference frequency */
	I2C_Stop();

	I2C_Start_Wait(0xD0);
	I2C_Write(CONFIG);									/* Write to Configuration register */
	I2C_Write(0x00);									/* Fs = 8KHz */
	I2C_Stop();

	I2C_Start_Wait(0xD0);
	I2C_Write(GYRO_CONFIG);								/* Write to Gyro configuration register */
	I2C_Write(0x18);									/* Full scale range +/- 2000 degree/C */
	I2C_Stop();

	I2C_Start_Wait(0xD0);
	I2C_Write(INT_ENABLE);								/* Write to interrupt enable register */
	I2C_Write(0x01);
	I2C_Stop();
}

void MPU_Start_Loc()
{
	I2C_Start_Wait(0xD0);								/* I2C start with device write address */
	I2C_Write(ACCEL_XOUT_H);							/* Write start location address from where to read */
	I2C_Repeated_Start(0xD1);							/* I2C start with device read address */
}

void Read_RawValue()
{
	MPU_Start_Loc();									/* Read Gyro values */
	Acc_x = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Acc_y = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Acc_z = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Temperature = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Gyro_x = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Gyro_y = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Gyro_z = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Nack());
	I2C_Stop();
}

void I2C_Init()												/* I2C initialize function */
{
	TWBR = 0x00;    //Clear Register
	TWSR = 0x00;    //Clear Register
	TWSR &= ~(1<<TWPS0);  //Set the prescaler bits to 0
	TWSR &= ~(1<<TWPS1);  //Set the prescaler bits to 0
	TWCR &= ~(1<<TWIE);   //Set acknowledge bit to 0
	TWBR = 32;
	//TWBR = BITRATE(TWSR = 0x00);							/* Get bit rate register value by formula */
}



uint8_t I2C_Repeated_Start(char slave_read_address)			/* I2C repeated start function */
{
	uint8_t status;											/* Declare variable */
	TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);					/* Enable TWI, generate start condition and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (start condition) */
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
	if (status != 0x10)										/* Check weather repeated start condition transmitted successfully or not? */
	return 0;												/* If no then return 0 to indicate repeated start condition fail */
	TWDR = slave_read_address;								/* If yes then write SLA+R in TWI data register */
	TWCR = (1<<TWEN)|(1<<TWINT);							/* Enable TWI and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (Write operation) */
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
	if (status == 0x40)										/* Check weather SLA+R transmitted & ack received or not? */
	return 1;												/* If yes then return 1 to indicate ack received */
	if (status == 0x20)										/* Check weather SLA+R transmitted & nack received or not? */
	return 2;												/* If yes then return 2 to indicate nack received i.e. device is busy */
	else
	return 3;												/* Else return 3 to indicate SLA+W failed */
}

void I2C_Stop()												/* I2C stop function */
{
	TWCR=(1<<TWSTO)|(1<<TWINT)|(1<<TWEN);					/* Enable TWI, generate stop condition and clear interrupt flag */
	while(TWCR & (1<<TWSTO));								/* Wait until stop condition execution */
}

void I2C_Start_Wait(char slave_write_address)				/* I2C start wait function */
{
	uint8_t status;											/* Declare variable */
	while (1)
	{
		TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);				/* Enable TWI, generate start condition and clear interrupt flag */
		while (!(TWCR & (1<<TWINT)));						/* Wait until TWI finish its current job (start condition) */
		status = TWSR & 0xF8;								/* Read TWI status register with masking lower three bits */
		if (status != 0x08)									/* Check weather start condition transmitted successfully or not? */
		continue;
		/* If no then continue with start loop again */
		TWDR = slave_write_address;							/* If yes then write SLA+W in TWI data register */
		TWCR = (1<<TWEN)|(1<<TWINT);						/* Enable TWI and clear interrupt flag */
		while (!(TWCR & (1<<TWINT)));						/* Wait until TWI finish its current job (Write operation) */
		status = TWSR & 0xF8;								/* Read TWI status register with masking lower three bits */
		if (status != 0x18 )								/* Check weather SLA+W transmitted & ack received or not? */
		{
			I2C_Stop();										/* If not then generate stop condition */
			continue;										/* continue with start loop again */
		}
		break;												/* If yes then break loop */
	}
}

uint8_t I2C_Write(char data)								/* I2C write function */
{
	uint8_t status;											/* Declare variable */
	TWDR = data;											/* Copy data in TWI data register */
	TWCR = (1<<TWEN)|(1<<TWINT);							/* Enable TWI and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (Write operation) */
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
	if (status == 0x28)										/* Check weather data transmitted & ack received or not? */
	return 0;												/* If yes then return 0 to indicate ack received */
	if (status == 0x30)										/* Check weather data transmitted & nack received or not? */
	return 1;												/* If yes then return 1 to indicate nack received */
	else
	return 2;												/* Else return 2 to indicate data transmission failed */
}

char I2C_Read_Ack()										/* I2C read ack function */
{
	TWCR=(1<<TWEN)|(1<<TWINT)|(1<<TWEA);					/* Enable TWI, generation of ack and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (read operation) */
	return TWDR;											/* Return received data */
}

char I2C_Read_Nack()										/* I2C read nack function */
{
	TWCR=(1<<TWEN)|(1<<TWINT);								/* Enable TWI and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (read operation) */
	return TWDR;											/* Return received data */
}

void USART_Init(unsigned long BAUDRATE)				/* USART initialize function */
{
	UCSR0B |= (1 << RXEN0) | (1 << TXEN0);				/* Enable USART transmitter and receiver */
	UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01);	/* Write USCRC for 8 bit data and 1 stop bit */
	UBRR0L = BAUD_PRESCALE;							/* Load UBRRL with lower 8 bit of prescale value */
	UBRR0H = (BAUD_PRESCALE >> 8);					/* Load UBRRH with upper 8 bit of prescale value */
}

char USART_RxChar()									/* Data receiving function */
{
	while (!(UCSR0A & (1 << RXC0)));					/* Wait until new data receive */
	return(UDR0);									/* Get and return received data */
}

void USART_TxChar(char data)						/* Data transmitting function */
{
	UDR0 = data;										/* Write data to be transmitting in UDR */
	while (!(UCSR0A & (1<<UDRE0)));					/* Wait until data transmit and buffer get empty */
}

void USART_SendString(char *str)					/* Send string of USART data function */
{
	int i=0;
	while (str[i]!=0)
	{
		USART_TxChar(str[i]);						/* Send each char of string till the NULL */
		i++;
	}
}

int main()
{
	char buffer[20], float_[10];
	double roll = 0.0, yaw= 0.0, pitch=0.0;
	double roll_acc, yaw_acc, pitch_acc;
	double dt = 0.005;
	double alpha = 0.9;
	double pi = 3.1415;
	float force;
	float Xa,Ya,Za;
	double a, b ,c;
	I2C_Init();											/* Initialize I2C */
	MPU6050_Init();										/* Initialize MPU6050 */
	USART_Init(9600);									/* Initialize USART with 9600 baud rate */
	
	while(1)
	{
		Read_RawValue();
		
		Acc_x = Acc_x/16384.0;
		_delay_ms(100);
		Acc_y = Acc_y/16384.0;
		_delay_ms(100);
		Acc_z = Acc_z/16384.0;
		_delay_ms(100);
		Gyro_x = Gyro_x/16.4;
		Gyro_y = Gyro_y/16.4;
		Gyro_z = Gyro_z/16.4;
		
		force = sqrt((Acc_x*Acc_x)+(Acc_y*Acc_y)+(Acc_z*Acc_z));
		
		roll_acc = (atan2(Acc_z,Acc_y))*180/pi;
		pitch_acc = (atan2(Acc_x,Acc_z))*180/pi;
		yaw_acc = (atan2(Acc_y,Acc_x))*180/pi;
		
		a = (roll + ((Gyro_x*dt)*180/pi))*alpha;
		b = (pitch + ((Gyro_y*dt)*180/pi))*alpha;
		c = (yaw + ((Gyro_z*dt)*180/pi))*alpha;
		
		
		roll = a + (1-alpha)*(roll_acc);
		pitch = b + (1-alpha)*(pitch_acc);
		yaw = c + (1-alpha)*(yaw_acc);
		
		Xa = (float) (roll);
		Ya = (float) (pitch);
		Za = (float) (yaw);
		
		

		 		dtostrf( Xa, 3, 2, float_ );					/* Take values in buffer to send all parameters over USART */
		 		sprintf(buffer," Ax = %s         ",float_);
		 		USART_SendString(buffer);
		 		USART_TxChar('\n');
		
		
		// 		dtostrf( force, 3, 2, float_ );					/* Take values in buffer to send all parameters over USART */
		// 		sprintf(buffer," F = %s         ",float_);
		// 		USART_SendString(buffer);
		// 		USART_TxChar('\n');
		


		
				dtostrf( Ya, 3, 2, float_ );
		 		sprintf(buffer," Ay = %s        ",float_);
		 		USART_SendString(buffer);
		 		USART_TxChar('\n');
		

		
		 		dtostrf( Za, 3, 2, float_ );
		 		sprintf(buffer," Az = %s         ",float_);
		 		USART_SendString(buffer);
		 		USART_TxChar('\n');
		

// 		if(((Ya<-60.0) && (Ya>-90.0)) && ((Xa>80.0) && (Xa<100.0))) {
// 			USART_TxChar('L');
// 		}
// 		
// 		if(((Ya<105.0) && (Ya>75.0)) && ((Xa>80.0) && (Xa<100.0))) {
// 			USART_TxChar('R');
// 		}
// 		
// 		if(((Ya<20.0) && (Ya>-20.0)) && ((Xa>-10.0) && (Xa<25.0))) {
// 			USART_TxChar('F');
// 		}
// 		
// 		if(((Ya<20.0) && (Ya>-20.0)) && ((Xa>155.0) && (Xa<190.0))) {
// 			USART_TxChar('B');
// 		}
// 		

	}
}


// external INTERRUPTS


/*
 * External interrupts.c
 *
 * Created: 2/2/2019 10:33:32 AM
 * Author : Siddharth Reddy
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>




int main(void)
{
    DDRE &= ~(1<<PINE6);
	DDRB |= (1<<PINB1);
	DDRB |= (1<<PINB0);
	PORTE |= (1<<PINE6);
	
	EICRB &= ~(1<<ISC61);
	EICRB |= (1<<ISC60);
	EIMSK |= (1<<INT6);
	sei();
	
	
    while (1) 
    {
		PORTB ^= (1<<PINB0);
		_delay_ms(1000);
	}
}

ISR(INT6_vect)
{
	PORTB &= ~(1<<PINB0);
	PORTB |= (1<<PINB1);
	_delay_ms(1000);
	PORTB &= ~(1<<PINB1); 
	
}

//TIMERS


/*
 * timer1.c
 *
 * Created: 2/2/2019 5:37:41 PM
 * Author : Siddharth Reddy
 */ 

#include <avr/io.h>
#define F_CPU 1000000
void Delay()
{
	TCCR0 = (1<<CS02) | (1<<CS00) | (1<<CS01);
	TCCR0 = ~(1<<WGM01) | ~(1<< WGM00);
	
	
	TCNT0 = 5;
	while((TIFR&(1<<TOV0))==0);
	TIFR = (1<<TOV0);
}




int main(void)
{{
	DDRB|=1<<PINB0;
	while(1)
	{
		PORTB ^=1 << PINB0;
		Delay();
	}
}



{

	TCNT0 =0xBA;
	TCCR0 =0x01;
	while ((TIFR & 0x1)==0);
	TCCR0 = 0;
	TIFR =0x1;

}
}

